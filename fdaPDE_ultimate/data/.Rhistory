particle_x <- c(2.5,2.5,1,1,pi/4)
particle_x
# POSTERIOR SIMULATION
library(ggplot2)
library(mvtnorm)
rm(list = ls())
integrand_evaluation <- function( V_1, V_2 , Rot, alpha, center, phi, H, z_observed, particle_x, tau ){
# mu* assembly:
term_1 = -(1-alpha)/alpha * center
term_2 = 1/alpha * (H %*% particle_x)
term_3 = tau * c(cos(phi) , sin(phi))
term_4 = - z_observed
mu_star = solve(Rot)%*%(term_1 + term_2 + term_3 + term_4)
# zeta_1 assembly:
zeta_1 = -0.5 * log(V_1[1,1]*V_1[2,2]-V_1[1,2]*V_1[2,1])
#auxiliary:
V_2_inv_mu_star = solve(V_2)%*%mu_star
#zeta_2 assembly:
logdet_2 = log(V_2[1,1]*V_2[2,2]-V_2[1,2]*V_2[2,1])
linear_term_2 = t(V_2_inv_mu_star) %*% V_2 %*% V_2_inv_mu_star
zeta_2 = -0.5 * ( logdet_2 + linear_term_2)
#zeta_bar assembly:
auxiliary_matrix = solve(V_1) + solve(V_2)
logdet_bar = - log( auxiliary_matrix[1,1]*auxiliary_matrix[2,2]-auxiliary_matrix[1,2]*auxiliary_matrix[2,1] )
linear_term_bar = t(V_2_inv_mu_star) %*% auxiliary_matrix %*% V_2_inv_mu_star;
zeta_bar = -0.5*( logdet_bar + linear_term_bar );
# integrand assembly:
# guarding_term = -(V_1[1,1]/2)^(-2.5) + 16*log(V_1[1,1])#constant term controlling the exploding behaviour of integrand when variances are low
integrand = exp( zeta_1 + zeta_2 - zeta_bar )
return(integrand)
}
measurement_distribution <- function(z_observed, particle_x, alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m ){
# compute the pdf of measurements according to measurements model
V_1 = (1-alpha)^2 / alpha^2 * diag(c(sigmaT^2,sigmaL^2))
Rot = rbind(c(cos(phi), -sin(phi)), c(sin(phi), cos(phi)))
V_2 = solve(t(Rot)%*%solve(Sigma)%*%Rot)
s_bar = alpha/(1-alpha) * s
# integrand_evaluation( V_1, V_2 , Rot, alpha, center, phi, H, z_observed, particle_x, tau )
# numerical integration: (trapezoid quadrature)
if(is.null(m)){ m = 16}
h = s_bar/m
nodes = seq(from = -s_bar/2, to = s_bar/2, by = h)
y = matrix(nrow = length(nodes), ncol = 1)
for(i in 1:length(nodes))
y[i,1] =  integrand_evaluation( V_1, V_2 , Rot, alpha, center, phi, H, z_observed, particle_x, nodes[i] )
integ = h*( 0.5*y[1,1] + sum(y[2:m,1]) + 0.5*y[m+1,1] )
pdf_values = integ
return(pdf_values)
}
# Hx = alpha*Z + (1-alpha)*C
# Z = 1/alpha(Hx - (1-alpha)c)
## TESTING ON A GRID OF POINT
particle_x <- c(2.5,2.5,1,1,pi/4)
alpha = 0.5
s = 7
center <- c(-2.5,-2.5)
phi <- pi/4
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 0.5
sigmaL = 3
Sigma = diag(c(2,2))
m = 8
z_observed = c(2.5,2.5)
center <- c(-2.5,-2.5)
pred_x <- c(0,0)
alpha = 0.5
s = 7
phi <- pi/4
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(2.5,2.5,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = -10
end_point = 10
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = z1[i]
x_grid[npoints*(i-1)+j,2] = z2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(z_observed[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=Z1, y=Z2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
z_observed = c(2.5,2.5)
center <- c(-2.5,-2.5)
pred_x <- c(0,0)
alpha = 0.5
s = 7
phi <- pi/4
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(2.5,2.5,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = -10
end_point = 10
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = z1[i]
x_grid[npoints*(i-1)+j,2] = z2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = x1[i]
x_grid[npoints*(i-1)+j,2] = x2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(z_observed[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=X1, y=X2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
for(i in 1:length(x_grid[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
library(mvtnorm)
install.packages("mvtnorm")
library(mvtnorm)
rm(list = ls())
integrand_evaluation <- function( V_1, V_2 , Rot, alpha, center, phi, H, z_observed, particle_x, tau ){
# mu* assembly:
term_1 = -(1-alpha)/alpha * center
term_2 = 1/alpha * (H %*% particle_x)
term_3 = tau * c(cos(phi) , sin(phi))
term_4 = - z_observed
mu_star = solve(Rot)%*%(term_1 + term_2 + term_3 + term_4)
# zeta_1 assembly:
zeta_1 = -0.5 * log(V_1[1,1]*V_1[2,2]-V_1[1,2]*V_1[2,1])
#auxiliary:
V_2_inv_mu_star = solve(V_2)%*%mu_star
#zeta_2 assembly:
logdet_2 = log(V_2[1,1]*V_2[2,2]-V_2[1,2]*V_2[2,1])
linear_term_2 = t(V_2_inv_mu_star) %*% V_2 %*% V_2_inv_mu_star
zeta_2 = -0.5 * ( logdet_2 + linear_term_2)
#zeta_bar assembly:
auxiliary_matrix = solve(V_1) + solve(V_2)
logdet_bar = - log( auxiliary_matrix[1,1]*auxiliary_matrix[2,2]-auxiliary_matrix[1,2]*auxiliary_matrix[2,1] )
linear_term_bar = t(V_2_inv_mu_star) %*% auxiliary_matrix %*% V_2_inv_mu_star;
zeta_bar = -0.5*( logdet_bar + linear_term_bar );
# integrand assembly:
# guarding_term = -(V_1[1,1]/2)^(-2.5) + 16*log(V_1[1,1])#constant term controlling the exploding behaviour of integrand when variances are low
integrand = exp( zeta_1 + zeta_2 - zeta_bar )
return(integrand)
}
measurement_distribution <- function(z_observed, particle_x, alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m ){
# compute the pdf of measurements according to measurements model
V_1 = (1-alpha)^2 / alpha^2 * diag(c(sigmaT^2,sigmaL^2))
Rot = rbind(c(cos(phi), -sin(phi)), c(sin(phi), cos(phi)))
V_2 = solve(t(Rot)%*%solve(Sigma)%*%Rot)
s_bar = alpha/(1-alpha) * s
# integrand_evaluation( V_1, V_2 , Rot, alpha, center, phi, H, z_observed, particle_x, tau )
# numerical integration: (trapezoid quadrature)
if(is.null(m)){ m = 16}
h = s_bar/m
nodes = seq(from = -s_bar/2, to = s_bar/2, by = h)
y = matrix(nrow = length(nodes), ncol = 1)
for(i in 1:length(nodes))
y[i,1] =  integrand_evaluation( V_1, V_2 , Rot, alpha, center, phi, H, z_observed, particle_x, nodes[i] )
integ = h*( 0.5*y[1,1] + sum(y[2:m,1]) + 0.5*y[m+1,1] )
pdf_values = integ
return(pdf_values)
}
z_observed = c(2.5,2.5)
center <- c(-2.5,-2.5)
pred_x <- c(0,0)
alpha = 0.5
s = 7
phi <- pi/4
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(2.5,2.5,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = -10
end_point = 10
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = x1[i]
x_grid[npoints*(i-1)+j,2] = x2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(x_grid[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=X1, y=X2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
z_observed = c(5,5)
center <- c(-5,-5)
pred_x <- c(-1,1)
alpha = 0.5
s = 7
phi <- pi/4
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(2.5,2.5,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = -10
end_point = 10
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = x1[i]
x_grid[npoints*(i-1)+j,2] = x2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(x_grid[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=X1, y=X2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
z_observed = c(7,7)
center <- c(-7,-7)
pred_x <- c(-3,3)
alpha = 0.5
s = 7
phi <- pi/4
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(2.5,2.5,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = -10
end_point = 10
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = x1[i]
x_grid[npoints*(i-1)+j,2] = x2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(x_grid[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=X1, y=X2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
###########################################
z_observed = c(619.8185,646.5487)
center <- c(617.69,636.4471)
pred_x <- c(619.8757,646.0852)
alpha = 0.5
s = 7
phi <- -0.085
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(619.8757,646.0852,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = 615
end_point = 620
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
begin_point = 635
end_point = 647
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = x1[i]
x_grid[npoints*(i-1)+j,2] = x2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(x_grid[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=X1, y=X2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
z_observed = c(619.8185,646.5487)
center <- c(617.69,636.4471)
pred_x <- c(619.8757,646.0852)
alpha = 0.5
s = 7
phi <- -0.085
H = rbind(c(1,0,0,0,0),c(0,1,0,0,0))
sigmaT = 1
sigmaL = 3
Sigma = diag(c(2,2))
state_sigma <- matrix(c(2,0,0,2),2,2)
m = 8
particle_x <- c(619.8757,646.0852,1,1,pi/4)
npoints = 100
x_grid <- matrix(nrow = npoints^2, ncol = 5)
prob_sampled <- matrix(nrow = npoints^2, ncol = 1)
begin_point = 615
end_point = 620
linspace = abs(begin_point-end_point)/(npoints-1)
x1 <- seq(from=begin_point, to=end_point, by=linspace)
begin_point = 635
end_point = 647
linspace = abs(begin_point-end_point)/(npoints-1)
x2 <- seq(from=begin_point, to=end_point, by=linspace)
for(i in 1:npoints){
for(j in 1:npoints){
x_grid[npoints*(i-1)+j,1] = x1[i]
x_grid[npoints*(i-1)+j,2] = x2[j]
x_grid[npoints*(i-1)+j,3] = 0
x_grid[npoints*(i-1)+j,4] = 0
x_grid[npoints*(i-1)+j,5] = 0
}
}
prob_sampled <- matrix(nrow = length(z_observed[,1]), ncol = 1)
for(i in 1:length(x_grid[,1])){
prob_value_1 <- measurement_distribution(z_observed, x_grid[i,], alpha, s, center, phi, H, sigmaT, sigmaL, Sigma , m )
prob_value_2 <- dmvnorm(x_grid[i,1:2], pred_x, state_sigma)
prob_sampled[i,1] <- prob_value_1*prob_value_2
print(i)
}
prob_distro <- data.frame(prob_sampled[,1], x_grid[,1],x_grid[,2])
names(prob_distro) <- c("probability", "X1", "X2")
p <- ggplot(prob_distro, aes(x=X1, y=X2 ,z=probability) ) +
#geom_bin2d() #+
geom_contour_filled()
#scale_fill_continuous(type = "viridis") +
#theme_bw()
p
.rs.restartR()
#.rs.restartR()
rm(list=ls())
graphics.off()
setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace")
#setwd("/Users/giuliopn/PACSworkspace3/PACSworkspace/")
library(fdaPDE)
library(purrr)
source("GAM_tests/2013_SSR_AllFunctions.R")
source("GAM_tests/gam_fem_fit.R")
library(fda)
logit <- function(x){qlogis(x)}
inv.logit <- function(x){plogis(x)}
#### square 2D (basic case)
# setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace/fdaPDE_ultimate/data")
data(square2Ddata)
mesh = fdaPDE::create.mesh.2D(nodes=nodes)
# x11()
plot(mesh, lwd=3, cex = 1.9)
# axis(1)
# axis(2)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
set.seed(5847947)
#### square 2D (basic case)
setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace/fdaPDE_ultimate/data")
#setwd("/Users/giuliopn/PACSworkspace3/PACSworkspace/fdaPDE_ultimate/data")
data(square2Ddata)
mesh = fdaPDE::create.mesh.2D(nodes=nodes)
# x11()
plot(mesh, lwd=3, cex = 1.9)
# axis(1)
# axis(2)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
#lambda= seq(10^-6,10^-3,by=5*10^-6)
lambda= 10^-2
GCVFLAG=F
GCVMETHODFLAG='Exact'
link<-function(x){logit(x)}
inv.link<-function(x){1/(1+exp(-x))}
desmat=matrix(0,nrow=nnodes,ncol=2)
desmat[,1]=rbeta(nnodes,shape1=1.5,shape2=2)  # sampling covariates from beta distr.
desmat[,2]=rbeta(nnodes,shape1=3,shape2=2)+1  # sampling covariates from beta distr.
beta1=-2/5
beta2=3/10
betas_truth = c(beta1,beta2)
param=sol_exact+beta1*desmat[,1]+beta2*desmat[,2]
#param = sol_exact
mu<-inv.link(param)
response <- rbernoulli(nnodes,p = mu)
output_CPP <- fdaPDE::gam.fem.fit(observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat,
lambda = lambda, max.steps=15, fam="binomial", mu0=NULL, mesh.const=T, scale.param=NULL)
betas_hat_CPP = output_CPP$beta_hat
betas_hat_CPP
