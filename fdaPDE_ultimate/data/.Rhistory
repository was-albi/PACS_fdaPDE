lambda= seq(10^-6,10^-3,by=5*10^-6)
GCVFLAG=T
GCVMETHODFLAG='Exact'
link<-function(x){logit(x)}
inv.link<-function(x){1/(1+exp(-x))}
desmat=matrix(0,nrow=nnodes,ncol=2)
desmat[,1]=rbeta(nnodes,shape1=1.5,shape2=2)  # sampling covariates from beta distr.
desmat[,2]=rbeta(nnodes,shape1=3,shape2=2)+1  # sampling covariates from beta distr.
beta1=-2/5
beta2=3/10
param=sol_exact+beta1*desmat[,1]+beta2*desmat[,2]
mu<-inv.link(param)
response <- rbernoulli(nnodes,p = mu)
output_CPP <- gam.fem.fit(observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat,
lambda = 10^-5, max.steps=15, fam="binomial", mesh.const=T, scale.param=NULL)
.rs.restartR()
library(fdaPDE)
library(purrr)
rm(list=ls())
graphics.off()
# setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace/fdaPDE_ultimate/data")
data(square2Ddata)
mesh=create.mesh.2D(nodes=nodes)
# x11()
plot(mesh)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
lambda= seq(10^-6,10^-3,by=5*10^-6)
GCVFLAG=T
GCVMETHODFLAG='Exact'
link<-function(x){logit(x)}
inv.link<-function(x){1/(1+exp(-x))}
desmat=matrix(0,nrow=nnodes,ncol=2)
desmat[,1]=rbeta(nnodes,shape1=1.5,shape2=2)  # sampling covariates from beta distr.
desmat[,2]=rbeta(nnodes,shape1=3,shape2=2)+1  # sampling covariates from beta distr.
beta1=-2/5
beta2=3/10
param=sol_exact+beta1*desmat[,1]+beta2*desmat[,2]
mu<-inv.link(param)
response <- rbernoulli(nnodes,p = mu)
output_CPP <- gam.fem.fit(observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat,
lambda = 10^-5, max.steps=15, fam="binomial", mesh.const=T, scale.param=NULL)
output_CPP$beta_hat
.rs.restartR()
rm(list=ls())
graphics.off()
# LOAD library ----------------------------------------
library(fdaPDE)
output_CPP<- fdaPDE::gam.fem.fit(1, "binomial", 1)
10^(-2:5)
# SIM_BERNOULLI with right mesh type
#.rs.restartR()
rm(list=ls())
.rs.restartR()
# SIM_BERNOULLI with right mesh type
#.rs.restartR()
rm(list=ls())
graphics.off()
#setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace")
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/")
library(fdaPDE)
library(purrr)
source("GAM_tests/2013_SSR_AllFunctions.R")
source("GAM_tests/gam_fem_fit.R")
source("GAM_tests/gam_fem.R")
library(fda)
logit <- function(x){qlogis(x)}
inv.logit <- function(x){plogis(x)}
# Build DATA: 2D mesh ---------------------------------
{
#### square 2D (basic case)
# setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace/fdaPDE_ultimate/data")
data(square2Ddata)
mesh = fdaPDE::create.mesh.2D(nodes=nodes)
# x11()
plot(mesh, lwd=3, cex = 1.9)
# axis(1)
# axis(2)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
}
set.seed(5847947)
# Build DATA: 2D mesh ---------------------------------
{
#### square 2D (basic case)
#setwd("/home/alb/Scrivania/PACS/Git_Folder/PACSworkspace/fdaPDE_ultimate/data")
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
data(square2Ddata)
mesh = fdaPDE::create.mesh.2D(nodes=nodes)
# x11()
plot(mesh, lwd=3, cex = 1.9)
# axis(1)
# axis(2)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
}
# Test function ------------------------------------
{
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
}
# Set smoothing parameter ---------------------------
{
link<-function(x){logit(x)}
inv.link<-function(x){1/(1+exp(-x))}
desmat=matrix(0,nrow=nnodes,ncol=2)
desmat[,1]=rbeta(nnodes,shape1=1.5,shape2=2)  # sampling covariates from beta distr.
desmat[,2]=rbeta(nnodes,shape1=3,shape2=2)+1  # sampling covariates from beta distr.
beta1=-2/5
beta2=3/10
betas_truth = c(beta1,beta2)
param=sol_exact+beta1*desmat[,1]+beta2*desmat[,2]
#param = sol_exact
mu<-inv.link(param)
response <- rbernoulli(nnodes,p = mu)
}
lambda = c(10^-2, 1, 10^2)
output_CPP <- fdaPDE::gam.fem.fit(observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat, GCV=T, GCVmethod = "Stochastic",
lambda = lambda, max.steps=15, fam="binomial", mu0=NULL, mesh.const=T, scale.param=NULL)
output_CPP$GCV
.rs.restartR()
# SIM_BERNOULLI with right mesh type
#.rs.restartR()
rm(list=ls())
graphics.off()
rm(list=ls())
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
# Load the mesh
data(simpleMesh2Ddata)
mesh=create.mesh.2D(nodes=nodes, triangles = triangles, order=2)
plot(mesh)
# Create the FEM basis object
FEMbasis = create.FEM.basis(mesh)
set.seed(5847947)
# Exact solution
data_exact=sin(pi*mesh$nodes[,1])
# Plot exact solution
plot(FEM(data_exact,FEMbasis = FEMbasis))
# Locations different from nodes
xobs=runif(min=-0.5,max=0.5,n=80)
yobs=runif(min=-0.5,max=0.5,n=80)
loc=cbind(xobs,yobs)
rm(list=ls())
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
# Exact test function
nnodes = sphere3D$nnodes
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
func_evaluation = numeric(nnodes)
for (i in 0:(nnodes-1)){
func_evaluation[i+1] = a1* sin(2*pi*sphere3D$nodes[i+1,1]) +  a2* sin(2*pi*sphere3D$nodes[i+1,2]) +  a3*sin(2*pi*sphere3D$nodes[i+1,3]) +1
}
ran=range(func_evaluation)
plot(FEM(func_evaluation,FEMbasis))
# Set smoothing parameter
lambda=c(10^-2)
set.seed(5847947)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
# Exact test function - locations different from nodes
func_evaluation2=numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation2[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) +1
}
ran2=range(func_evaluation2)
set.seed(5847947)
cov1_nonod=4*sin(2*pi*loc[,1])+6*sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
W2=cbind(cov1_nonod,cov2_nonod)
beta_exact=c(0.3,0.5)
ran=range(W2%*%beta_exact + func_evaluation2)
data=func_evaluation2 + W2%*%beta_exact + rnorm(nloc,mean=0,sd=0.05*(ran[2]-ran[1]))
.rs.restartR()
#.rs.restartR()
rm(list=ls())
#.rs.restartR()
rm(list=ls())
graphics.off()
rm(list=ls())
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
GCVFLAG=TRUE
GCVMETHODFLAG='Stochastic' #for stochastic GCV (default)
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
# Exact test function
nnodes = sphere3D$nnodes
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
func_evaluation = numeric(nnodes)
for (i in 0:(nnodes-1)){
func_evaluation[i+1] = a1* sin(2*pi*sphere3D$nodes[i+1,1]) +  a2* sin(2*pi*sphere3D$nodes[i+1,2]) +  a3*sin(2*pi*sphere3D$nodes[i+1,3]) +1
}
ran=range(func_evaluation)
plot(FEM(func_evaluation,FEMbasis))
# Set smoothing parameter
lambda=c(10^-2)
set.seed(5847947)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
# Exact test function - locations different from nodes
func_evaluation2=numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation2[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) +1
}
ran2=range(func_evaluation2)
set.seed(5847947)
cov1_nonod=4*sin(2*pi*loc[,1])+6*sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
W2=cbind(cov1_nonod,cov2_nonod)
beta_exact=c(0.3,0.5)
ran=range(W2%*%beta_exact + func_evaluation2)
data=func_evaluation2 + W2%*%beta_exact + rnorm(nloc,mean=0,sd=0.05*(ran[2]-ran[1]))
output_CPP = smooth.FEM(observations = data,locations=loc, covariates=W2,
FEMbasis = FEMbasis, lambda = lambda, GCV = GCVFLAG, GCVmethod = GCVMETHODFLAG)
output_CPP <- fdaPDE::gam.fem.fit(observations = data,locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, mesh.const=T, scale.param=scale.param)
scale.param = 0.1
output_CPP <- fdaPDE::gam.fem.fit(observations = data,locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, mesh.const=T, scale.param=scale.param)
.rs.restartR()
#.rs.restartR()
rm(list=ls())
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
# Load the mesh
data(simpleMesh2Ddata)
mesh=create.mesh.2D(nodes=nodes, triangles = triangles, order=2)
rm(list=ls())
rm(list=ls())
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
GCVFLAG=TRUE
GCVMETHODFLAG='Stochastic' #for stochastic GCV (default)
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
# Exact test function
nnodes = sphere3D$nnodes
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
func_evaluation = numeric(nnodes)
for (i in 0:(nnodes-1)){
func_evaluation[i+1] = a1* sin(2*pi*sphere3D$nodes[i+1,1]) +  a2* sin(2*pi*sphere3D$nodes[i+1,2]) +  a3*sin(2*pi*sphere3D$nodes[i+1,3]) +1
}
ran=range(func_evaluation)
plot(FEM(func_evaluation,FEMbasis))
# Set smoothing parameter
lambda=c(10^-2)
set.seed(5847947)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
# Exact test function - locations different from nodes
func_evaluation2=numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation2[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) +1
}
ran2=range(func_evaluation2)
set.seed(5847947)
cov1_nonod=4*sin(2*pi*loc[,1])+6*sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
W2=cbind(cov1_nonod,cov2_nonod)
beta_exact=c(0.3,0.5)
ran=range(W2%*%beta_exact + func_evaluation2)
data=func_evaluation2 + W2%*%beta_exact + rnorm(nloc,mean=0,sd=0.05*(ran[2]-ran[1]))
scale.param = 0.1
output_CPP <- fdaPDE::gam.fem.fit(observations = data,locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, mesh.const=T, scale.param=scale.param)
output_CPP <- fdaPDE::gam.fem.fit(observations = data,locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, scale.param=scale.param)
output_CPP$beta
output_CPP
rm(list=ls())
.rs.restartR()
rm(list=ls())
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
GCVFLAG=TRUE
GCVMETHODFLAG='Stochastic' #for stochastic GCV (default)
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
# Exact test function
nnodes = sphere3D$nnodes
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
func_evaluation = numeric(nnodes)
for (i in 0:(nnodes-1)){
func_evaluation[i+1] = a1* sin(2*pi*sphere3D$nodes[i+1,1]) +  a2* sin(2*pi*sphere3D$nodes[i+1,2]) +  a3*sin(2*pi*sphere3D$nodes[i+1,3]) +1
}
ran=range(func_evaluation)
# Set smoothing parameter
lambda=c(10^-2)
set.seed(5847947)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
# Exact test function - locations different from nodes
func_evaluation2=numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation2[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) +1
}
ran2=range(func_evaluation2)
set.seed(5847947)
cov1_nonod=4*sin(2*pi*loc[,1])+6*sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
W2=cbind(cov1_nonod,cov2_nonod)
beta_exact=c(0.3,0.5)
ran=range(W2%*%beta_exact + func_evaluation2)
data=func_evaluation2 + W2%*%beta_exact + rnorm(nloc,mean=0,sd=0.05*(ran[2]-ran[1]))
scale.param = 0.1
output_CPP <- fdaPDE::gam.fem.fit(observations = data, locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, scale.param=scale.param)
output_CPP <- gam.fem.fit(observations = data, locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, scale.param=scale.param)
.rs.restartR()
rm(list=ls())
library(fdaPDE)
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
GCVFLAG=TRUE
GCVMETHODFLAG='Stochastic' #for stochastic GCV (default)
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
# Exact test function
nnodes = sphere3D$nnodes
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
func_evaluation = numeric(nnodes)
for (i in 0:(nnodes-1)){
func_evaluation[i+1] = a1* sin(2*pi*sphere3D$nodes[i+1,1]) +  a2* sin(2*pi*sphere3D$nodes[i+1,2]) +  a3*sin(2*pi*sphere3D$nodes[i+1,3]) +1
}
ran=range(func_evaluation)
plot(FEM(func_evaluation,FEMbasis))
# Set smoothing parameter
lambda=c(10^-2)
set.seed(5847947)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
# Exact test function - locations different from nodes
func_evaluation2=numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation2[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) +1
}
ran2=range(func_evaluation2)
set.seed(5847947)
cov1_nonod=4*sin(2*pi*loc[,1])+6*sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
W2=cbind(cov1_nonod,cov2_nonod)
beta_exact=c(0.3,0.5)
ran=range(W2%*%beta_exact + func_evaluation2)
data=func_evaluation2 + W2%*%beta_exact + rnorm(nloc,mean=0,sd=0.05*(ran[2]-ran[1]))
scale.param = 0.1
output_CPP <- gam.fem.fit(observations = data, locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, scale.param=scale.param)
FEMbasis$mesh$order
.rs.restartR()
#### sphere 3D (covariates + locations not at nodes + stochastic GCV) ####
#.rs.restartR()
rm(list=ls())
library(fdaPDE)
setwd("/Users/giuliopn/PACSworkspace4/PACS_fdaPDE/fdaPDE_ultimate/data")
GCVFLAG=TRUE
GCVMETHODFLAG='Stochastic' #for stochastic GCV (default)
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
# Exact test function
nnodes = sphere3D$nnodes
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
func_evaluation = numeric(nnodes)
for (i in 0:(nnodes-1)){
func_evaluation[i+1] = a1* sin(2*pi*sphere3D$nodes[i+1,1]) +  a2* sin(2*pi*sphere3D$nodes[i+1,2]) +  a3*sin(2*pi*sphere3D$nodes[i+1,3]) +1
}
ran=range(func_evaluation)
# Set smoothing parameter
lambda=c(10^-2)
set.seed(5847947)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
# Exact test function - locations different from nodes
func_evaluation2=numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation2[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) +1
}
ran2=range(func_evaluation2)
set.seed(5847947)
cov1_nonod=4*sin(2*pi*loc[,1])+6*sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
W2=cbind(cov1_nonod,cov2_nonod)
beta_exact=c(0.3,0.5)
ran=range(W2%*%beta_exact + func_evaluation2)
data=func_evaluation2 + W2%*%beta_exact + rnorm(nloc,mean=0,sd=0.05*(ran[2]-ran[1]))
scale.param = 0.1
output_CPP <- gam.fem.fit(observations = data, locations=loc, FEMbasis =FEMbasis, covariates = W2,
lambda = lambda, max.steps=15, fam="gaussian", mu0=NULL, scale.param=scale.param)
output_CPP$beta_hat
output_CPP = smooth.FEM(observations = data,locations=loc, covariates=W2,
FEMbasis = FEMbasis, lambda = lambda, GCV = GCVFLAG, GCVmethod = GCVMETHODFLAG)
#.rs.restartR()
rm(list=ls())
graphics.off()
